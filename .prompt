// MVP Preparation Configuration and Templates
// Format is valid TypeScript to avoid linting errors

/** 
 * Component templates
 */
export const componentTemplates = {
  server: `import { type FC } from 'react';

interface \${ComponentName}Props {
  // Add props here
}

export const \${ComponentName}: FC<\${ComponentName}Props> = () => {
  return (
    <div>
      {/* Component content */}
    </div>
  );
}`,
  
  client: `'use client';

import { type FC } from 'react';

interface \${ComponentName}Props {
  // Add props here
}

export const \${ComponentName}: FC<\${ComponentName}Props> = () => {
  return (
    <div>
      {/* Component content */}
    </div>
  );
}`
};

/**
 * Repository template
 */
export const repositoryTemplate = `import { createClient } from '@/lib/supabase/server';
import { type Database } from '@/types/supabase';

export class \${Name}Repository {
  private supabase = createClient();

  async getById(id: string) {
    const { data, error } = await this.supabase
      .from('\${tableName}')
      .select('*')
      .eq('id', id)
      .single();

    if (error) throw error;
    return data;
  }

  async list(options?: { limit?: number; offset?: number; filters?: Record<string, any> }) {
    let query = this.supabase.from('\${tableName}').select('*');
    
    if (options?.filters) {
      Object.entries(options.filters).forEach(([key, value]) => {
        if (value !== undefined) query = query.eq(key, value);
      });
    }
    
    if (options?.limit) query = query.limit(options.limit);
    if (options?.offset) query = query.range(options.offset, options.offset + (options.limit || 10) - 1);
    
    const { data, error } = await query;
    if (error) throw error;
    return data;
  }
  
  async create(data: any) {
    const { data: result, error } = await this.supabase.from('\${tableName}').insert(data).select().single();
    if (error) throw error;
    return result;
  }
  
  async update(id: string, data: any) {
    const { data: result, error } = await this.supabase.from('\${tableName}').update(data).eq('id', id).select().single();
    if (error) throw error;
    return result;
  }
  
  async delete(id: string) {
    const { error } = await this.supabase.from('\${tableName}').delete().eq('id', id);
    if (error) throw error;
    return true;
  }
}`;

/**
 * API route template
 */
export const apiRouteTemplate = `import { createClient } from '@/lib/supabase/server';
import { NextResponse } from 'next/server';

export async function GET(request: Request) {
  try {
    const supabase = createClient();
    // Add route logic here
    return NextResponse.json({ message: 'Success' });
  } catch (error) {
    console.error('API error:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}`;

/**
 * Server action template
 */
export const serverActionTemplate = `'use server';

import { revalidatePath } from 'next/cache';
import { createClient } from '@/lib/supabase/server';

type \${Name}Data = {
  // Add data fields here
};

export async function create\${Name}(data: \${Name}Data) {
  try {
    const supabase = createClient();
    
    const { data: result, error } = await supabase
      .from('\${tableName}')
      .insert(data)
      .select()
      .single();
      
    if (error) throw error;
    
    revalidatePath('/\${path}');
    return { success: true, data: result };
  } catch (error) {
    console.error('Server action error:', error);
    return { success: false, error: 'Failed to create \${name}' };
  }
}`;

/**
 * MVP feature: Email Verification
 */
export const emailVerificationFeature = {
  schema: {
    types: `export interface VerificationRequest {
  email: string;
  token: string;
  expires: Date;
}

export interface PasswordResetRequest {
  email: string;
  token: string;
  expires: Date;
}`
  },
  components: [
    "EmailVerification",
    "ResetPassword",
    "VerificationStatus"
  ],
  actions: [
    "sendVerificationEmail",
    "verifyEmail",
    "requestPasswordReset",
    "resetPassword"
  ],
  apiRoutes: [
    "/api/auth/verify",
    "/api/auth/reset-password"
  ]
};

/**
 * MVP feature: Checkout Flow
 */
export const checkoutFeature = {
  components: [
    "CheckoutForm",
    "OrderConfirmation",
    "PaymentForm",
    "ShippingForm"
  ],
  actions: [
    "createOrder",
    "processPayment",
    "validateShipping"
  ],
  apiRoutes: [
    "/api/checkout",
    "/api/orders",
    "/api/payment/stripe"
  ]
};

/**
 * MVP feature: Custom Orders
 */
export const customOrdersFeature = {
  components: [
    "CustomOrderForm",
    "DesignUpload",
    "OrderTracking",
    "AdminNotification"
  ],
  actions: [
    "submitCustomOrder",
    "uploadDesign",
    "getOrderStatus",
    "updateOrderStatus"
  ],
  apiRoutes: [
    "/api/custom-orders",
    "/api/uploads/design",
    "/api/custom-orders/[id]"
  ]
};

/**
 * MVP Implementation Config
 */
export const mvpConfig = {
  order: ["email", "checkout", "customOrders"],
  steps: [
    "Implement email verification",
    "Test purchase flow",
    "Optimize custom order process",
    "Finalize mobile responsiveness",
    "Prepare for deployment"
  ],
  timeline: {
    emailVerification: "3 days",
    purchaseFlow: "2 days",
    customOrders: "2 days",
    responsiveness: "2 days",
    deployment: "1 day"
  },
  priorityIssues: [
    "Email verification flow",
    "Payment processing",
    "Order confirmation",
    "Mobile layout issues"
  ]
}; 